{"version":3,"file":"ngx-order-pipe.umd.min.js","sources":["~/ngx-order-pipe/src/app/order-pipe/ngx-order.pipe.ts","~/ngx-order-pipe/src/app/order-pipe/ngx-order.module.ts"],"sourcesContent":["import { Pipe, PipeTransform } from '@angular/core';\nexport class OrderPipe implements PipeTransform {\n/**\n * Check if a value is a string\n * \n * @param {?} value\n * @return {?}\n */\nstatic isString(value: any) {\n    return typeof value === 'string' || value instanceof String;\n  }\n/**\n * Sorts values ignoring the case\n * \n * @param {?} a\n * @param {?} b\n * @return {?}\n */\nstatic caseInsensitiveSort(a: any, b: any) {\n    if (OrderPipe.isString(a) && OrderPipe.isString(b)) {\n      return a.localeCompare(b);\n    }\n    return OrderPipe.defaultCompare(a, b);\n  }\n/**\n * Default compare method\n * \n * @param {?} a\n * @param {?} b\n * @return {?}\n */\nstatic defaultCompare(a: any, b: any) {\n    if (a === b) {\n      return 0;\n    }\n    if (a == null) {\n      return 1;\n    }\n    if (b == null) {\n      return -1;\n    }\n    return a > b ? 1 : -1;\n  }\n/**\n * Parse expression, split into items\n * @param {?} expression\n * @return {?}\n */\nstatic parseExpression(expression: string): string[] {\n    expression = expression.replace(/\\[(\\w+)\\]/g, '.$1');\n    expression = expression.replace(/^\\./, '');\n    return expression.split('.');\n  }\n/**\n * Get value by expression\n * \n * @param {?} object\n * @param {?} expression\n * @return {?}\n */\nstatic getValue(object: any, expression: string[]) {\n    for (let /** @type {?} */ i = 0, /** @type {?} */ n = expression.length; i < n; ++i) {\n      const /** @type {?} */ k = expression[i];\n      if (!(k in object)) {\n        return;\n      }\n      object = object[k];\n    }\n\n    return object;\n  }\n/**\n * Set value by expression\n * \n * @param {?} object\n * @param {?} value\n * @param {?} expression\n * @return {?}\n */\nstatic setValue(object: any, value: any, expression: string[]) {\n    let /** @type {?} */ i;\n    for (i = 0; i < expression.length - 1; i++) {\n      object = object[expression[i]];\n    }\n\n    object[expression[i]] = value;\n  }\n/**\n * @param {?} value\n * @param {?=} expression\n * @param {?=} reverse\n * @param {?=} isCaseInsensitive\n * @param {?=} comparator\n * @return {?}\n */\ntransform(value: any | any[], expression?: any, reverse?: boolean, isCaseInsensitive: boolean = false, comparator?: Function): any {\n    if (!value) {\n      return value;\n    }\n\n    if (Array.isArray(expression)) {\n      return this.multiExpressionTransform(value, expression, reverse, isCaseInsensitive, comparator);\n    }\n    \n    if (Array.isArray(value)) {\n      return this.sortArray(value.slice(), expression, reverse, isCaseInsensitive, comparator);\n    }\n    \n    if (typeof value === 'object') {\n      return this.transformObject(Object.assign({}, value), expression, reverse, isCaseInsensitive, comparator);\n    }\n\n    return value;\n  }\n/**\n * Sort array\n * \n * @param {?} value\n * @param {?=} expression\n * @param {?=} reverse\n * @param {?=} isCaseInsensitive\n * @param {?=} comparator\n * @return {?}\n */\nprivate sortArray(value: any[], expression?: any, reverse?: boolean, isCaseInsensitive?: boolean, comparator?: Function): any[] {\n    const /** @type {?} */ isDeepLink = expression && expression.indexOf('.') !== -1;\n\n    if (isDeepLink) {\n      expression = OrderPipe.parseExpression(expression);\n    }\n\n    let /** @type {?} */ compareFn: Function;\n    \n    if (comparator && typeof comparator === 'function') {\n      compareFn = comparator;\n    } else {\n      compareFn = isCaseInsensitive ? OrderPipe.caseInsensitiveSort : OrderPipe.defaultCompare;\n    }\n    \n    let /** @type {?} */ array: any[] = value.sort((a: any, b: any): number => {\n      if (!expression) {\n        return compareFn(a, b);\n      }\n\n      if (!isDeepLink) {\n        if (a && b) {\n          return compareFn(a[expression], b[expression]);\n        }\n        return compareFn(a, b);\n      }\n      \n      return compareFn(OrderPipe.getValue(a, expression), OrderPipe.getValue(b, expression));\n    });\n\n    if (reverse) {\n      return array.reverse();\n    }\n\n    return array;\n  }\n/**\n * Transform Object\n * \n * @param {?} value\n * @param {?=} expression\n * @param {?=} reverse\n * @param {?=} isCaseInsensitive\n * @param {?=} comparator\n * @return {?}\n */\nprivate transformObject(value: any | any[], expression?: any, reverse?: boolean, isCaseInsensitive?: boolean, comparator?: Function): any {\n\n    let /** @type {?} */ parsedExpression = OrderPipe.parseExpression(expression);\n    let /** @type {?} */ lastPredicate = parsedExpression.pop();\n    let /** @type {?} */ oldValue = OrderPipe.getValue(value, parsedExpression);\n\n    if (!Array.isArray(oldValue)) {\n      parsedExpression.push(lastPredicate);\n      lastPredicate = null;\n      oldValue = OrderPipe.getValue(value, parsedExpression);\n    }\n\n    if (!oldValue) {\n      return value;\n    }\n\n    OrderPipe.setValue(value, this.transform(oldValue, lastPredicate, reverse, isCaseInsensitive), parsedExpression);\n    return value;\n  }\n/**\n * Apply multiple expressions\n * \n * @param {?} value\n * @param {?} expressions\n * @param {?} reverse\n * @param {?=} isCaseInsensitive\n * @param {?=} comparator\n * @return {?}\n */\nprivate multiExpressionTransform(value: any, expressions: any[], reverse: boolean, isCaseInsensitive: boolean = false, comparator?: Function): any {\n    return expressions.reverse().reduce((result: any, expression: any) => {\n      return this.transform(result, expression, reverse, isCaseInsensitive, comparator);\n    }, value);\n  }\nstatic decorators: DecoratorInvocation[] = [\n{ type: Pipe, args: [{\n  name: 'orderBy',\n  pure: false\n}, ] },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n];\n}\n\nfunction OrderPipe_tsickle_Closure_declarations() {\n/** @type {?} */\nOrderPipe.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nOrderPipe.ctorParameters;\n}\n\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n","/**\n * Created by vadimdez on 20/01/2017.\n */\n\nimport { NgModule } from '@angular/core';\nimport { OrderPipe } from './ngx-order.pipe';\nexport class OrderModule {static decorators: DecoratorInvocation[] = [\n{ type: NgModule, args: [{\n  declarations: [OrderPipe],\n  exports: [OrderPipe],\n  providers: [OrderPipe]\n}, ] },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n];\n}\n\nfunction OrderModule_tsickle_Closure_declarations() {\n/** @type {?} */\nOrderModule.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nOrderModule.ctorParameters;\n}\n\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n"],"names":["OrderPipe","isString","value","String","caseInsensitiveSort","a","b","localeCompare","defaultCompare","parseExpression","expression","replace","split","getValue","object","i","n","length","k","setValue","prototype","transform","reverse","isCaseInsensitive","comparator","Array","isArray","this","multiExpressionTransform","sortArray","slice","transformObject","Object","assign","compareFn","isDeepLink","indexOf","array","sort","parsedExpression","lastPredicate","pop","oldValue","push","expressions","_this","reduce","result","decorators","type","Pipe","args","name","pure","ctorParameters","OrderModule","NgModule","declarations","exports","providers"],"mappings":"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"}
